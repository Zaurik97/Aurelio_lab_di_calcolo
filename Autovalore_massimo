PROGRAM autovalore

    IMPLICIT NONE

    REAL(KIND=8), ALLOCATABLE :: matrice(:,:)             
    REAL(KIND=8), ALLOCATABLE :: valori_sqrt(:), valori_rapporto(:)
    CHARACTER(LEN=:), ALLOCATABLE :: nome_file 
    INTEGER :: i, j, n, limite, unita_file

    ALLOCATE(CHARACTER(LEN=20) :: nome_file)
    nome_file = "dati.dat"
    unita_file = 10

    limite = 1000

    PRINT *, "Inserire la dimensione della matrice:"
    READ *, n

    ALLOCATE(matrice(n, n))!allocazione dinamica della memoria
    ALLOCATE(valori_sqrt(limite), valori_rapporto(limite))

    CALL InizializzazioneMatrice(matrice, n)

    PRINT *, "La matrice inserita è:"
    DO i = 1, n
        PRINT *, (matrice(i, j), j = 1, n)
    END DO

    OPEN(unit=unita_file, file=nome_file, status='replace')

    ! Intestazione
    WRITE(unita_file, '(A)') "# iterazione   metodo_sqrt              metodo_rapporto"

    !CALL CalcolaAutovalori(matrice, n)!massimo autovalore con metodo classico
    CALL trovaMaxAutovaloreSQRT(matrice, n, limite, valori_sqrt)
    CALL trovaMaxAutovaloreRapporto(matrice, n, limite, valori_rapporto)

    DO i = 1, limite !scrivo i risultati nel file tutti nello stesso momento
        WRITE(unita_file, '(I5, F25.15, F25.15)') i, valori_sqrt(i), valori_rapporto(i)
    END DO

    PRINT *, "Risultati scritti con successo nel file."

    DEALLOCATE(matrice)!libero la memoria dinamicamente assegnata
    DEALLOCATE(valori_sqrt, valori_rapporto)
    DEALLOCATE(nome_file)

CONTAINS

SUBROUTINE InizializzazioneMatrice(mat, n)
    REAL(KIND=8), INTENT(INOUT) :: mat(:,:)
    INTEGER, INTENT(IN) :: n
    DOUBLE PRECISION :: entrateMatrice
    INTEGER :: i, j

    DO i = 1, n
        DO j = 1, n
            PRINT *, "Inserisci l'elemento (", i, ",", j, "):"
            READ *, entrateMatrice
            mat(i, j) = REAL(entrateMatrice, KIND=8)
        END DO
    END DO
END SUBROUTINE InizializzazioneMatrice

SUBROUTINE trovaMaxAutovaloreSQRT(mat, n, limit, risultati)
    REAL(KIND=8), INTENT(IN) :: mat(:,:)
    INTEGER, INTENT(IN) :: n, limit
    REAL(KIND=8), INTENT(OUT) :: risultati(limit)
    REAL(KIND=8), ALLOCATABLE :: Ak(:,:), temp(:,:)
    INTEGER :: i, k
    REAL(KIND=8) :: trace, valore_corrente, ultimo_valido

    ALLOCATE(Ak(n,n), temp(n,n))
    Ak = mat

    ultimo_valido = 0.0_8  

    DO k = 1, limit

        trace = 0.0_8
        DO i = 1, n
            trace = trace + Ak(i, i)
        END DO

        valore_corrente = trace ** (1.0_8 / REAL(k, KIND=8))

        IF (.NOT. (valore_corrente == valore_corrente) .OR. ABS(valore_corrente) >= HUGE(valore_corrente)) THEN
            risultati(k) = ultimo_valido
        ELSE
            risultati(k) = valore_corrente
            ultimo_valido = valore_corrente
        END IF

        temp = MATMUL(Ak, mat)
        Ak = temp
    END DO

    DEALLOCATE(Ak, temp)

    PRINT '(A, F25.15)', "Valore finale (metodo radice):", ultimo_valido
END SUBROUTINE trovaMaxAutovaloreSQRT

SUBROUTINE trovaMaxAutovaloreRapporto(mat, n, limit, risultati)
    REAL(KIND=8), INTENT(IN) :: mat(:,:)
    INTEGER, INTENT(IN) :: n, limit
    REAL(KIND=8), INTENT(OUT) :: risultati(limit)
    REAL(KIND=8), ALLOCATABLE :: Ak(:,:), temp(:,:)
    INTEGER :: i, k
    REAL(KIND=8) :: trace_k, trace_k1, valore_corrente, ultimo_valido

    ALLOCATE(Ak(n,n), temp(n,n))
    Ak = mat

    ultimo_valido = 0.0_8  

    DO k = 1, limit

        trace_k = 0.0_8
        DO i = 1, n
            trace_k = trace_k + Ak(i, i)
        END DO


        temp = MATMUL(Ak, mat)


        trace_k1 = 0.0_8
        DO i = 1, n
            trace_k1 = trace_k1 + temp(i, i)
        END DO

        IF (trace_k /= 0.0_8) THEN
            valore_corrente = trace_k1 / trace_k
        ELSE
            valore_corrente = 0.0_8
        END IF

        IF (.NOT. (valore_corrente == valore_corrente) .OR. ABS(valore_corrente) >= HUGE(valore_corrente)) THEN
            risultati(k) = ultimo_valido
        ELSE
            risultati(k) = valore_corrente
            ultimo_valido = valore_corrente
        END IF

        Ak = temp
    END DO

    DEALLOCATE(Ak, temp)

    PRINT '(A, F25.15)', "Valore finale (metodo rapporto):", ultimo_valido
END SUBROUTINE trovaMaxAutovaloreRapporto

    ! Funzione per calcolare gli autovalori nel modo classico
SUBROUTINE CalcolaAutovalori(mat,n)
        REAL(KIND=8), INTENT(INOUT) :: mat(:,:)
        INTEGER, INTENT(IN) :: n
        REAL(KIND=8), ALLOCATABLE :: autovalori(:)
        REAL :: maxAutovalore
        CHARACTER(LEN=1) :: jobz, uplo
        INTEGER :: info

        ! Allocazione della variabile per gli autovalori
        ALLOCATE(autovalori(n))

        ! Configurazione per LAPACK
        jobz = 'N'  ! 'N' = calcola solo gli autovalori, 'V' = calcola anche gli autovettori
        uplo = 'U'  ! 'U' = usa la parte superiore della matrice, 'L' = usa inferiore

        ! Calcolo degli autovalori con DSYEV
        CALL DSYEV(jobz, uplo, n, mat, n, autovalori, info)

        ! Controllo il risultato
        IF (info /= 0) THEN
            PRINT *, "Errore nella diagonalizzazione: codice", info
            STOP "Errore durante il calcolo degli autovalori"
        ELSE
            maxAutovalore = MAXVAL(autovalori)
            PRINT '(A, F25.15)',"il valore dell´autovalore massimo trovato col metodo classico é:",maxAutovalore
        END IF
    END SUBROUTINE CalcolaAutovalori

END PROGRAM autovalore
